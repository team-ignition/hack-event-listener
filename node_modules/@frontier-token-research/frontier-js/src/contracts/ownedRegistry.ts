import { abi } from '../services/contractsParser';


export default class OwnedRegistryContract {
  ownedRegistryContract: any;
  contractName: string;
  ownedRegistryAddress: string;
  web3: any;

  constructor(web3: any, ownedRegistryAddress: string) {
    this.contractName = 'OwnedRegistry';
    this.ownedRegistryContract = new web3.eth.Contract(
      abi(this.contractName),
      ownedRegistryAddress
    );
    this.ownedRegistryAddress = ownedRegistryAddress;
    this.web3 = web3;
    this.applyAccount = this.applyAccount;
    this.removeFromList = this.removeFromList;
    this.whiteList = this.whiteList;
    this.isWhiteListed = this.isWhiteListed;
    this.listingCounter = this.listingCounter;
  }
  /*
   * Write the blockchain
   */
  removeFromList(accountToRemove: string, adminAddress: string) {
    return new Promise((resolve, reject) => {
      this.ownedRegistryContract.methods
        .remove(accountToRemove)
        .send({ from: adminAddress })
        .then((result: any) => resolve(result));
    });
  }
  whiteList(accountToWhiteList: string, adminAddress: string) {
    return new Promise((resolve, reject) => {
      this.ownedRegistryContract.methods
        .whiteList(accountToWhiteList)
        .send({ from: adminAddress })
        .then((result: any) => resolve(result));
    });
  }
  applyAccount(identifier: string, amount: number, data: string, adminAddress: string, gas?: number, gasPrice?: number) {
    return new Promise((resolve, reject) => {
      if (gas && gasPrice !== undefined) {
        this.ownedRegistryContract.methods.apply(identifier, amount, data)
        .send({ from: adminAddress, gas, gasPrice }).then((result: any) => resolve(result));
      } else {
        this.ownedRegistryContract.methods.apply(identifier, amount, data)
        .send({ from: adminAddress }).then((result: any) => resolve(result));
      }
    }); 
    
  }
  /*
   * Read the blockchain
   */
  isWhiteListed(addressToTest: string) {
    return new Promise((resolve, reject) => {
      this.ownedRegistryContract.methods
        .isWhitelisted(addressToTest)
        .call()
        .then((isWhiteListed: any) => resolve(isWhiteListed));
    });
  }
  listingCounter() {
    return new Promise((resolve, reject) => {
      this.ownedRegistryContract.methods
        .listingCounter()
        .call()
        .then((listingCounter: any) => resolve(listingCounter));
    });
  }
}
